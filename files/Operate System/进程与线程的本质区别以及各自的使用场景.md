# **进程、线程的区别和使用场景**  
## 1. 进程  
* 进程是一个能独立运行的基本单位，也是**系统进行资源分配和调度**的一个独立单位 。  

* 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。  

* 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。  

* 进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。  

## 2. 线程  
* 引入：为什么需要线程  

    * 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。  

    * 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。  

* 线程是进程的一个实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。  

## 3. 区别  
* 线程是进程的一个实体，是比进程更小的能独立运行的基本单位  

* 进程有独立的地址空间，而线程没有，线程只有自己的栈、程序计数器、寄存器（属于同一进程的线程，堆是共享的，栈是私有的。属于同一进程的所有线程都具有相同的地址空间。）  

* 进程崩溃时不会对其他进程产生影响，线程崩溃时整个进程都会崩溃  

* 进程切换、创建、销毁比较麻烦，线程比较简单  


## 4. 多进程和多线程的对比
 | **对比维度** |**多进程**|  	**多线程**
 |-------------|----------|----------
 |**数据共享、同步**|	数据共享复杂，需要用IPC；数据是分开的，同步简单|	因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂  
 |**内存、CPU**|	占用内存多，切换复杂，CPU利用率低|	占用内存少，切换简单，CPU利用率高  
 |**创建销毁、切换**|	创建销毁、切换复杂，速度慢|	创建销毁、切换简单，速度很快  
 |**编程、调试**|	编程简单，调试简单|	编程复杂，调试复杂  
 |**可靠性**|	进程间不会互相影响|	一个线程挂掉将导致整个进程挂掉  
 |**分布式**|	适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|	适应于多核分布式  
 
 ## 5. 各自适用的场景
1. 多进程应用场景

nginx主流的工作模式是多进程模式（也支持多线程模型）
几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程；
chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）
redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）
2. 多线程应用场景

线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）。
提供非均质的服务（有优先级任务处理）事件响应有优先级。
单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延。
与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）
案例：
桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程；memcached
 
* 需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的

* 需要进行大量计算的优先使用线程（CPU频繁切换）
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。

* 强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。

* 可能要扩展到多机分布的用进程，多核分布的用线程 

* 需要安全稳定时用进程，需要速度时用进程，既要速度又要安全。 
